C51 COMPILER V9.01   ZYWIFI0939C超_波_障程序（不_1602显示）                             07/12/2016 17:18:33 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE ZYWIFI0939C超_波_障程序（不_1602显示）
OBJECT MODULE PLACED IN ZYWIFI0939C超声波避障程序（不带1602显示）.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ZYWIFI0939C超声波避障程序（不带1602显示）.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          /**********************ZYWIFI0939C-WIFI机器人实验板例程************************
   2          *  平台：ZYWIFI0939C-WIFI机器人 + Keil U4 + STC89C52
   3          *  名称：ZY-1智能小车参考程序
   4          *  公司：湖南智宇科教设备有限公司
   5          *  淘宝：https://hnzyrobot1688.taobao.com/     
   6          *  网站：www.hnzhiyu.cn 
   7          *  编写：智宇公司研发一部
   8          *  日期：2015-1-15
   9          *  交流:智能车QQ:261339276
  10          *  晶振:11.0592MHZ
  11          *  说明：免费开源，不提供源代码分析
  12          *  硬件设置：要有自己动手能力，才能完成实验
  13          *  使用说明：根据下面IO口自己用杜邦线连接各种模块，可以自己修改各种模块IO口
  14          *  视频教程：本小车配套学习C语言详细视频教程，资料统一网盘下载
  15             重点提示：本程序只做参考，不提供技术支持，请自己研究吸收。
  16          ******************************************************************/
  17          #include <at89x51.h>    
  18          #include <intrins.h>
  19          
  20          #define  TX  P2_1
  21          #define  RX  P2_0
  22          
  23          #define Forward_L_DATA  180//当前进不能走直线的时候，请调节这两个参数，理想的时候是100,100，最大256，最小0
             -。0的时候最慢，256的时候最快
  24          #define Forward_R_DATA  180     //例如小车前进的时候有点向左拐，说明右边马达转速过快，那可以取一个值大一点，另
             -外一个值小一点，例如 200  190
  25                                      //直流电机因为制造上的误差，同一个脉宽下也不一定速度一致的，需要自己手动调节
  26          
  27          
  28          /*****按照原图接线定义******/
  29          sbit L293D_IN1=P1^2; 
  30          sbit L293D_IN2=P1^3;
  31          sbit L293D_IN3=P1^4;
  32          sbit L293D_IN4=P1^5;
  33          sbit L293D_EN1=P1^6;
  34          sbit L293D_EN2=P1^7;
  35          
  36          sbit BUZZ=P2^3;
  37          
  38          
  39          void Delay400Ms(void);//延时400毫秒函数
  40          
  41          
  42          unsigned char disbuff[4]={0,0,0,0};//用于分别存放距离的值0.1mm、mm、cm和m的值
  43          
  44          void Count(void);//距离计算函数
  45                                    
  46          unsigned int  time=0;//用于存放定时器时间值
  47          unsigned long S=0;//用于存放距离的值
  48          bit  flag =0; //量程溢出标志位
  49          bit  turn_right_flag;
  50          
  51          
  52          //********************************************************** 
  53          //函数名称:Delay1ms(unsigned int i) 
C51 COMPILER V9.01   ZYWIFI0939C超_波_障程序（不_1602显示）                             07/12/2016 17:18:33 PAGE 2   

  54          //函数功能:延时i*1ms的子程序(对应于22.1184Mhz晶振)   
  55          //形式参数:unsigned int i 
  56          //行参说明:无 
  57          //返回参数:无 
  58          //使用说明:i为要延时的时间长度，单位是MS，最大可以延时65536 ms 
  59          //********************************************************** 
  60          void Delay1ms(unsigned int i) 
  61          { 
  62   1      unsigned char j,k; 
  63   1      do{ 
  64   2        j = 10; 
  65   2        do{ 
  66   3         k = 50; 
  67   3         do{ 
  68   4          _nop_(); 
  69   4         }while(--k);     
  70   3        }while(--j); 
  71   2      }while(--i); 
  72   1      
  73   1      } 
  74          //********************************************************** 
  75          //函数名称:Delay10us(unsigned char i) 
  76          //函数功能:延时i*10us的子程序(对应于22.1184Mhz晶振)   
  77          //形式参数:无 
  78          //行参说明:无 
  79          //返回参数:无 
  80          //使用说明:i为要延时的时间长度，单位是US，最大可以延时250 ms 
  81          //********************************************************** 
  82          void Delay10us(unsigned char i) 
  83          { 
  84   1         unsigned char j; 
  85   1      do{ 
  86   2        j = 10; 
  87   2        do{ 
  88   3         _nop_(); 
  89   3         }while(--j); 
  90   2      }while(--i); 
  91   1      }  
  92          
  93          //========================================================================================================
             -=================
  94          void Forward()//           前进
  95          {
  96   1      
  97   1               L293D_IN1=1; 
  98   1               L293D_IN2=0;
  99   1               L293D_IN3=1;
 100   1               L293D_IN4=0;
 101   1      //     PWM_Set(255-Speed_Right,255-Speed_Left);
 102   1      }
 103          void  backrun()//          后退
 104          {
 105   1      
 106   1               L293D_IN1=0; 
 107   1               L293D_IN2=1;
 108   1               L293D_IN3=0;
 109   1               L293D_IN4=1;
 110   1      //     PWM_Set(255-Speed_Right,255-Speed_Left);
 111   1      }
 112          void Stop(void) //刹车
 113          {
 114   1      
C51 COMPILER V9.01   ZYWIFI0939C超_波_障程序（不_1602显示）                             07/12/2016 17:18:33 PAGE 3   

 115   1           L293D_IN1=0; 
 116   1               L293D_IN2=0;
 117   1               L293D_IN3=0;
 118   1               L293D_IN4=0;
 119   1      //       PWM_Set(0,0);
 120   1      }
 121          void Turn_Retreat()      //左
 122          {
 123   1          L293D_IN1=0; 
 124   1              L293D_IN2=0;
 125   1              L293D_IN3=0;
 126   1              L293D_IN4=1;
 127   1      //      PWM_Set(255-Speed_Right,255-Speed_Left);
 128   1      }
 129          
 130          void Turn_left()         //右
 131          {
 132   1          L293D_IN1=1; 
 133   1              L293D_IN2=0;
 134   1              L293D_IN3=0;
 135   1              L293D_IN4=0;
 136   1      //      PWM_Set(255-Speed_Right,255-Speed_Left);
 137   1      }
 138          
 139          //========================================================================================================
             -=================
 140          /********距离计算程序***************/
 141              void Conut(void)
 142                  {
 143   1               time=TH1*256+TL1;
 144   1               TH1=0;
 145   1               TL1=0;
 146   1              
 147   1               //此时time的时间单位决定于晶振的速度，外接晶振为11.0592MHZ时，
 148   1                          //time的值为0.54us*time，单位为微秒
 149   1                                      //那么1us声波能走多远的距离呢？1s=1000ms=1000000us 
 150   1                                      // 340/1000000=0.00034米
 151   1                                      //0.00034米/1000=0.34毫米  也就是1us能走0.34毫米
 152   1                                      //但是，我们现在计算的是从超声波发射到反射接收的双路程，
 153   1                                      //所以我们将计算的结果除以2才是实际的路程
 154   1      
 155   1              S=time*2;//先算出一共的时间是多少微秒。
 156   1              S=S*0.17;//此时计算到的结果为毫米，并且是精确到毫米的后两位了，有两个小数点 
 157   1               if(S<=400)      //
 158   1               {      
 159   2                  if(turn_right_flag!=1)
 160   2                      {
 161   3                          Stop();
 162   3                          Delay1ms(5);//发现小车自动复位的时候，可以稍微延长一点这个延时，减少电机反向电压对电路板的冲击。
 163   3                      }
 164   2                      turn_right_flag=1;
 165   2                      
 166   2                      P2_3=0;
 167   2      
 168   2                      Delay1ms(50);
 169   2                      
 170   2                      P2_3=1;
 171   2                  backrun();
 172   2                 Delay1ms(300);       // 关键点  延时5MS  
 173   2                 Turn_left();
 174   2                 Delay1ms(400);         //左转800MS
 175   2      
C51 COMPILER V9.01   ZYWIFI0939C超_波_障程序（不_1602显示）                             07/12/2016 17:18:33 PAGE 4   

 176   2               }
 177   1               else
 178   1               {
 179   2                  turn_right_flag=0;
 180   2                  //Forward(Forward_R_DATA,Forward_L_DATA);
 181   2                      Forward();
 182   2      
 183   2               }
 184   1               //=======================================
 185   1               if((S>=5000)||flag==1) //超出测量范围
 186   1               {      
 187   2                flag=0;
 188   2            //DisplayListChar(0, 1, table1);
 189   2               }
 190   1               else
 191   1               {
 192   2            disbuff[0]=S%10;
 193   2                disbuff[1]=S/10%10;
 194   2                disbuff[2]=S/100%10;
 195   2                disbuff[3]=S/1000;
 196   2               }
 197   1              }
 198          
 199          /********************************************************/
 200               void zd0() interrupt 3              //T0中断用来计数器溢出,超过测距范围
 201            {
 202   1          flag=1;                      //中断溢出标志
 203   1              RX=0;
 204   1        }
 205          
 206          /********超声波高电平脉冲宽度计算程序***************/
 207          void Timer_Count(void)
 208          {
 209   1                       TR1=1;                     //开启计数
 210   1                   while(RX);                 //当RX为1计数并等待
 211   1                   TR1=0;                             //关闭计数
 212   1               Conut();                       //计算
 213   1      
 214   1      }
 215          /********************************************************/
 216             void  StartModule()                   //启动模块
 217            {
 218   1                TX=1;                                      //启动一次模块
 219   1            Delay10us(2);
 220   1                TX=0;
 221   1        }
 222          /********************************************************/ 
 223          
 224          /*************主程序********************/
 225          void main(void)
 226          {
 227   1          unsigned char i;
 228   1              unsigned int a;
 229   1              Delay1ms(5);//延时片刻
 230   1          TMOD=TMOD|0x10;//设T0为方式1，GATE=1；
 231   1          EA=1;
 232   1          TH1=0;
 233   1          TL1=0;          
 234   1          ET1=1;             //允许T0中断
 235   1                                         //开启总中断
 236   1      
 237   1              turn_right_flag=0;
C51 COMPILER V9.01   ZYWIFI0939C超_波_障程序（不_1602显示）                             07/12/2016 17:18:33 PAGE 5   

 238   1              //=================================
 239   1      B:              for(i=0;i<50;i++) //判断K3是否按下
 240   1                      {
 241   2                         Delay1ms(1); //1ms内判断50次，如果其中有一次被判断到K3没按下，便重新检测
 242   2                         if(P3_2!=0 )//当S1按下时，启动小车
 243   2                         goto B; //跳转到标号B，重新检测
 244   2                      }
 245   1              //蜂鸣器响一声
 246   1              BUZZ=0; //50次检测K3确认是按下之后，蜂鸣器发出“滴”声响，然后启动小车。
 247   1              Delay1ms(50);
 248   1              BUZZ=1;//响50ms后关闭蜂鸣器
 249   1              //=======================================================================================================
             -================                      
 250   1              while(1)
 251   1                {
 252   2                      RX=1;
 253   2                  StartModule();
 254   2              for(a=951;a>0;a--)
 255   2                  {
 256   3                         
 257   3                     if(RX==1)
 258   3                         {
 259   4                 Timer_Count();
 260   4                         }
 261   3               }
 262   2              }
 263   1      } 
 264          
 265          
 266          
 267                          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    454    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     10       2
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
